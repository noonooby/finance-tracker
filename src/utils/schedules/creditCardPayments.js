import { supabase } from '../supabase';
import { formatCurrency } from '../helpers';
import { dbOperation, updateBankAccountBalance, getCashInHand, updateCashInHand } from '../db';
import { logActivity } from '../activityLogger';

/**
 * Credit Card Payment Management
 * Handles processing credit card payments with proper history tracking
 */

/**
 * Process overdue credit card payments (replaces old processOverdueCreditCards)
 */
export async function processOverdueCreditCardPayments(creditCards, bankAccounts = [], cashInHand = 0) {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayString = today.toISOString().split('T')[0];

    console.log('üîÑ Processing overdue credit card payments...');

    const results = {
      processed: [],
      failed: [],
      skipped: []
    };

    const overdueCards = creditCards.filter(card => {
      if (card.is_gift_card) return false; // Skip gift cards
      if (!card.due_date) return false;
      const dueDate = new Date(card.due_date);
      dueDate.setHours(0, 0, 0, 0);
      return dueDate <= today && (Number(card.balance) || 0) > 0;
    });

    if (overdueCards.length === 0) {
      console.log('‚úÖ No overdue credit cards');
      return results;
    }

    console.log(`üìä Found ${overdueCards.length} overdue card(s)`);

    for (const card of overdueCards) {
      try {
        const paymentAmount = Number(card.balance) || 0; // Full balance
        if (paymentAmount <= 0) {
          results.skipped.push({
            card: card.name,
            reason: 'No outstanding balance'
          });
          continue;
        }

        // Determine payment source
        let paymentSource = null;
        let paymentSourceId = null;
        let paymentSourceName = null;
        let paymentSourceType = null;

        if (card.connected_payment_source && card.connected_payment_source_id) {
          if (card.connected_payment_source === 'bank_account') {
            const account = bankAccounts.find(a => String(a.id) === String(card.connected_payment_source_id));
            if (account) {
              const balance = Number(account.balance) || 0;
              if (balance >= paymentAmount) {
                paymentSource = account;
                paymentSourceId = account.id;
                paymentSourceName = account.name;
                paymentSourceType = 'bank_account';
              }
            }
          } else if (card.connected_payment_source === 'cash_in_hand') {
            if (cashInHand >= paymentAmount) {
              paymentSourceType = 'cash_in_hand';
              paymentSourceName = 'Cash in Hand';
            }
          }
        }

        if (!paymentSourceType) {
          results.failed.push({
            card: card.name,
            reason: 'No available payment source with sufficient funds'
          });
          continue;
        }

        // Create the payment
        const result = await createCreditCardPayment({
          cardId: card.id,
          amount: paymentAmount,
          paymentDate: todayString,
          dueDate: card.due_date,
          paymentSource: paymentSourceType,
          paymentSourceId,
          paymentSourceName,
          autoGenerated: true
        }, card, paymentSource);

        if (result.success) {
          results.processed.push({
            card: card.name,
            amount: paymentAmount,
            source: paymentSourceName,
            sourceType: paymentSourceType
          });
        } else {
          results.failed.push({
            card: card.name,
            reason: result.error || 'Processing failed'
          });
        }

      } catch (error) {
        console.error(`‚ùå Error processing card ${card.name}:`, error);
        results.failed.push({
          card: card.name,
          reason: error.message || 'Unknown error'
        });
      }
    }

    console.log('‚úÖ Credit card payment processing complete');
    console.log(`   Processed: ${results.processed.length}`);
    console.log(`   Failed: ${results.failed.length}`);
    console.log(`   Skipped: ${results.skipped.length}`);

    return results;

  } catch (error) {
    console.error('‚ùå Error processing overdue credit cards:', error);
    throw error;
  }
}

/**
 * Create a credit card payment record
 */
export async function createCreditCardPayment(paymentData, card, paymentSource) {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    const amount = Number(paymentData.amount) || 0;
    const cardBalance = Number(card.balance) || 0;
    const previousCardBalance = cardBalance;
    const newCardBalance = 0; // Full payment

    // Process payment from source
    if (paymentData.paymentSource === 'bank_account' && paymentSource) {
      const currentBalance = Number(paymentSource.balance) || 0;
      if (currentBalance < amount) {
        return { success: false, error: `Insufficient funds in ${paymentSource.name}` };
      }
      const newBalance = currentBalance - amount;
      await updateBankAccountBalance(paymentSource.id, newBalance);
      
    } else if (paymentData.paymentSource === 'cash_in_hand') {
      const currentCash = await getCashInHand();
      if (currentCash < amount) {
        return { success: false, error: 'Insufficient cash in hand' };
      }
      const newCash = currentCash - amount;
      await updateCashInHand(newCash);
    }

    // Create payment record
    const payment = {
      user_id: user.id,
      card_id: paymentData.cardId,
      amount: amount,
      payment_date: paymentData.paymentDate,
      due_date: paymentData.dueDate,
      payment_source: paymentData.paymentSource,
      payment_source_id: paymentData.paymentSourceId || null,
      payment_source_name: paymentData.paymentSourceName,
      status: 'completed',
      auto_generated: paymentData.autoGenerated || false,
      balance_before: previousCardBalance,
      balance_after: newCardBalance,
      created_at: new Date().toISOString()
    };

    const { data: paymentRecord, error: paymentError } = await supabase
      .from('credit_card_payments')
      .insert(payment)
      .select()
      .single();

    if (paymentError) throw paymentError;

    // Create transaction
    const transaction = {
      type: 'payment',
      card_id: card.id,
      amount: amount,
      date: paymentData.paymentDate,
      category_id: 'credit_card_payment',
      category_name: 'Credit Card Payment',
      payment_method: paymentData.paymentSource,
      payment_method_id: paymentData.paymentSourceId,
      payment_method_name: paymentData.paymentSourceName,
      description: `Credit card payment for ${card.name} from ${paymentData.paymentSourceName}`,
      status: 'active',
      auto_generated: paymentData.autoGenerated || false,
      created_at: new Date().toISOString()
    };

    const savedTransaction = await dbOperation('transactions', 'put', transaction, { skipActivityLog: true });

    // Update card - calculate next due date (add 1 month to current due date)
    const currentDueDate = new Date(card.due_date);
    const nextDueDate = new Date(currentDueDate);
    nextDueDate.setMonth(nextDueDate.getMonth() + 1);
    const nextDueDateString = nextDueDate.toISOString().split('T')[0];

    await dbOperation('creditCards', 'put', {
      ...card,
      balance: newCardBalance,
      last_payment_date: paymentData.paymentDate,
      last_auto_payment_date: paymentData.autoGenerated ? paymentData.paymentDate : card.last_auto_payment_date,
      last_payment_amount: amount,
      due_date: nextDueDateString
    }, { skipActivityLog: true });

    // Log activity
    await logActivity(
      'credit_card_payment',
      'card',
      card.id,
      card.name,
      `Credit card payment: ${formatCurrency(amount)} for ${card.name} from ${paymentData.paymentSourceName} - Balance ${formatCurrency(previousCardBalance)} ‚Üí ${formatCurrency(newCardBalance)}`,
      {
        paymentId: paymentRecord.id,
        transactionId: savedTransaction?.id,
        amount,
        paymentSource: paymentData.paymentSource,
        paymentSourceId: paymentData.paymentSourceId,
        paymentSourceName: paymentData.paymentSourceName,
        balanceBefore: previousCardBalance,
        balanceAfter: newCardBalance
      }
    );

    console.log(`‚úÖ Credit card payment created: ${card.name} - ${formatCurrency(amount)}`);

    return { success: true, payment: paymentRecord };

  } catch (error) {
    console.error('Error creating credit card payment:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Get credit card payment history
 */
export async function getCreditCardPaymentHistory(cardId) {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    const { data, error } = await supabase
      .from('credit_card_payments')
      .select('*')
      .eq('card_id', cardId)
      .eq('user_id', user.id)
      .order('payment_date', { ascending: false });

    if (error) throw error;
    return data || [];

  } catch (error) {
    console.error('Error fetching credit card payment history:', error);
    return [];
  }
}

/**
 * Undo a credit card payment
 */
export async function undoCreditCardPayment(paymentId) {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    // Get payment record
    const { data: payment, error: fetchError } = await supabase
      .from('credit_card_payments')
      .select('*')
      .eq('id', paymentId)
      .eq('user_id', user.id)
      .single();

    if (fetchError) throw fetchError;
    if (!payment) throw new Error('Payment not found');

    const amount = Number(payment.amount) || 0;

    // Reverse payment source
    if (payment.payment_source === 'bank_account' && payment.payment_source_id) {
      const { data: account } = await supabase
        .from('bank_accounts')
        .select('*')
        .eq('id', payment.payment_source_id)
        .eq('user_id', user.id)
        .single();

      if (account) {
        const currentBalance = Number(account.balance) || 0;
        const restoredBalance = currentBalance + amount;
        await updateBankAccountBalance(payment.payment_source_id, restoredBalance);
      }
      
    } else if (payment.payment_source === 'cash_in_hand') {
      const currentCash = await getCashInHand();
      const restoredCash = currentCash + amount;
      await updateCashInHand(restoredCash);
    }

    // Restore card balance
    const card = await dbOperation('creditCards', 'get', payment.card_id);
    if (card) {
      const restoredBalance = (payment.balance_before !== undefined && payment.balance_before !== null)
        ? Number(payment.balance_before)
        : Number(card.balance) + amount;

      // Roll back due date (subtract 1 month)
      const currentDueDate = new Date(card.due_date);
      const previousDueDate = new Date(currentDueDate);
      previousDueDate.setMonth(previousDueDate.getMonth() - 1);
      const previousDueDateString = previousDueDate.toISOString().split('T')[0];

      await dbOperation('creditCards', 'put', {
        ...card,
        balance: restoredBalance,
        due_date: previousDueDateString
      }, { skipActivityLog: true });
    }

    // Mark payment as undone
    await supabase
      .from('credit_card_payments')
      .update({
        status: 'undone',
        undone_at: new Date().toISOString()
      })
      .eq('id', paymentId);

    // Mark transaction as undone
    if (payment.transaction_id) {
      await supabase
        .from('transactions')
        .update({
          status: 'undone',
          undone_at: new Date().toISOString()
        })
        .eq('id', payment.transaction_id);
    }

    console.log('‚úÖ Credit card payment undone successfully');
    return true;

  } catch (error) {
    console.error('Error undoing credit card payment:', error);
    throw error;
  }
}
