import { supabase } from '../supabase';
import { predictNextDate, formatCurrency } from '../helpers';
import { dbOperation, getBankAccount, updateBankAccountBalance, getCashInHand, updateCashInHand } from '../db';
import { logActivity } from '../activityLogger';

/**
 * Loan Payment Management
 * Handles processing loan payments with proper history tracking
 */

/**
 * Process overdue loan payments (replaces old processOverdueLoans)
 */
export async function processOverdueLoanPayments(loans, creditCards = [], bankAccounts = [], cashInHand = 0) {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayString = today.toISOString().split('T')[0];

    console.log('üîÑ Processing overdue loan payments...');

    const results = {
      processed: [],
      failed: [],
      skipped: []
    };

    const overdueLoans = loans.filter(loan => {
      if (!loan.next_payment_date) return false;
      const dueDate = new Date(loan.next_payment_date);
      dueDate.setHours(0, 0, 0, 0);
      return dueDate <= today;
    });

    if (overdueLoans.length === 0) {
      console.log('‚úÖ No overdue loans');
      return results;
    }

    console.log(`üìä Found ${overdueLoans.length} overdue loan(s)`);

    for (const loan of overdueLoans) {
      try {
        const paymentAmount = Number(loan.payment_amount) || 0;
        if (paymentAmount <= 0) {
          results.skipped.push({
            loan: loan.name,
            reason: 'No payment amount configured'
          });
          continue;
        }

        // Determine payment source
        let paymentSource = null;
        let paymentSourceId = null;
        let paymentSourceName = null;
        let paymentSourceType = null;

        if (loan.connected_payment_source && loan.connected_payment_source_id) {
          if (loan.connected_payment_source === 'credit_card') {
            const card = creditCards.find(c => String(c.id) === String(loan.connected_payment_source_id));
            if (card) {
              paymentSource = card;
              paymentSourceId = card.id;
              paymentSourceName = card.name;
              paymentSourceType = 'credit_card';
            }
          } else if (loan.connected_payment_source === 'bank_account') {
            const account = bankAccounts.find(a => String(a.id) === String(loan.connected_payment_source_id));
            if (account) {
              const balance = Number(account.balance) || 0;
              if (balance >= paymentAmount) {
                paymentSource = account;
                paymentSourceId = account.id;
                paymentSourceName = account.name;
                paymentSourceType = 'bank_account';
              }
            }
          } else if (loan.connected_payment_source === 'cash_in_hand') {
            if (cashInHand >= paymentAmount) {
              paymentSourceType = 'cash_in_hand';
              paymentSourceName = 'Cash in Hand';
            }
          }
        }

        if (!paymentSourceType) {
          results.failed.push({
            loan: loan.name,
            reason: 'No available payment source with sufficient funds'
          });
          continue;
        }

        // Create the payment
        const result = await createLoanPayment({
          loanId: loan.id,
          amount: paymentAmount,
          paymentDate: todayString,
          dueDate: loan.next_payment_date,
          paymentSource: paymentSourceType,
          paymentSourceId,
          paymentSourceName,
          autoGenerated: true
        }, loan, paymentSource);

        if (result.success) {
          results.processed.push({
            loan: loan.name,
            amount: paymentAmount,
            source: paymentSourceName,
            sourceType: paymentSourceType
          });
        } else {
          results.failed.push({
            loan: loan.name,
            reason: result.error || 'Processing failed'
          });
        }

      } catch (error) {
        console.error(`‚ùå Error processing loan ${loan.name}:`, error);
        results.failed.push({
          loan: loan.name,
          reason: error.message || 'Unknown error'
        });
      }
    }

    console.log('‚úÖ Loan payment processing complete');
    console.log(`   Processed: ${results.processed.length}`);
    console.log(`   Failed: ${results.failed.length}`);
    console.log(`   Skipped: ${results.skipped.length}`);

    return results;

  } catch (error) {
    console.error('‚ùå Error processing overdue loans:', error);
    throw error;
  }
}

/**
 * Create a loan payment record
 */
export async function createLoanPayment(paymentData, loan, paymentSource) {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    const amount = Number(paymentData.amount) || 0;
    const loanBalance = Number(loan.balance) || 0;
    const previousLoanBalance = loanBalance;
    const newLoanBalance = Math.max(0, loanBalance - amount);

    // Process payment from source
    if (paymentData.paymentSource === 'bank_account' && paymentSource) {
      const currentBalance = Number(paymentSource.balance) || 0;
      if (currentBalance < amount) {
        return { success: false, error: `Insufficient funds in ${paymentSource.name}` };
      }
      const newBalance = currentBalance - amount;
      await updateBankAccountBalance(paymentSource.id, newBalance);
      
    } else if (paymentData.paymentSource === 'credit_card' && paymentSource) {
      const currentBalance = Number(paymentSource.balance) || 0;
      const newBalance = currentBalance + amount;
      await dbOperation('creditCards', 'put', {
        ...paymentSource,
        balance: newBalance,
        last_payment_date: paymentData.paymentDate
      }, { skipActivityLog: true });
      
    } else if (paymentData.paymentSource === 'cash_in_hand') {
      const currentCash = await getCashInHand();
      if (currentCash < amount) {
        return { success: false, error: 'Insufficient cash in hand' };
      }
      const newCash = currentCash - amount;
      await updateCashInHand(newCash);
    }

    // Create payment record
    const payment = {
      user_id: user.id,
      loan_id: paymentData.loanId,
      amount: amount,
      payment_date: paymentData.paymentDate,
      due_date: paymentData.dueDate,
      payment_source: paymentData.paymentSource,
      payment_source_id: paymentData.paymentSourceId || null,
      payment_source_name: paymentData.paymentSourceName,
      status: 'completed',
      auto_generated: paymentData.autoGenerated || false,
      balance_before: previousLoanBalance,
      balance_after: newLoanBalance,
      created_at: new Date().toISOString()
    };

    const { data: paymentRecord, error: paymentError } = await supabase
      .from('loan_payments')
      .insert(payment)
      .select()
      .single();

    if (paymentError) throw paymentError;

    // Create transaction
    const transaction = {
      type: 'payment',
      loan_id: loan.id,
      amount: amount,
      date: paymentData.paymentDate,
      category_id: 'loan_payment',
      category_name: 'Loan Payment',
      payment_method: paymentData.paymentSource,
      payment_method_id: paymentData.paymentSourceId,
      payment_method_name: paymentData.paymentSourceName,
      description: `Loan payment for ${loan.name} from ${paymentData.paymentSourceName}`,
      status: 'active',
      auto_generated: paymentData.autoGenerated || false,
      created_at: new Date().toISOString()
    };

    const savedTransaction = await dbOperation('transactions', 'put', transaction, { skipActivityLog: true });

    // Update loan
    const nextDate = predictNextDate(loan.next_payment_date, loan.frequency || 'monthly');
    const completedCount = (loan.recurring_occurrences_completed || 0) + 1;

    await dbOperation('loans', 'put', {
      ...loan,
      balance: newLoanBalance,
      last_payment_date: paymentData.paymentDate,
      last_auto_payment_date: paymentData.autoGenerated ? paymentData.paymentDate : loan.last_auto_payment_date,
      next_payment_date: nextDate,
      recurring_occurrences_completed: completedCount
    }, { skipActivityLog: true });

    // Log activity
    await logActivity(
      'loan_payment',
      'loan',
      loan.id,
      loan.name,
      `Loan payment: ${formatCurrency(amount)} for ${loan.name} from ${paymentData.paymentSourceName} - Balance ${formatCurrency(previousLoanBalance)} ‚Üí ${formatCurrency(newLoanBalance)}`,
      {
        paymentId: paymentRecord.id,
        transactionId: savedTransaction?.id,
        amount,
        paymentSource: paymentData.paymentSource,
        paymentSourceId: paymentData.paymentSourceId,
        paymentSourceName: paymentData.paymentSourceName,
        balanceBefore: previousLoanBalance,
        balanceAfter: newLoanBalance
      }
    );

    console.log(`‚úÖ Loan payment created: ${loan.name} - ${formatCurrency(amount)}`);

    return { success: true, payment: paymentRecord };

  } catch (error) {
    console.error('Error creating loan payment:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Get loan payment history
 */
export async function getLoanPaymentHistory(loanId) {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    const { data, error } = await supabase
      .from('loan_payments')
      .select('*')
      .eq('loan_id', loanId)
      .eq('user_id', user.id)
      .order('payment_date', { ascending: false });

    if (error) throw error;
    return data || [];

  } catch (error) {
    console.error('Error fetching loan payment history:', error);
    return [];
  }
}

/**
 * Undo a loan payment
 */
export async function undoLoanPayment(paymentId) {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    // Get payment record
    const { data: payment, error: fetchError } = await supabase
      .from('loan_payments')
      .select('*')
      .eq('id', paymentId)
      .eq('user_id', user.id)
      .single();

    if (fetchError) throw fetchError;
    if (!payment) throw new Error('Payment not found');

    const amount = Number(payment.amount) || 0;

    // Reverse payment source
    if (payment.payment_source === 'bank_account' && payment.payment_source_id) {
      const { data: account } = await supabase
        .from('bank_accounts')
        .select('*')
        .eq('id', payment.payment_source_id)
        .eq('user_id', user.id)
        .single();

      if (account) {
        const currentBalance = Number(account.balance) || 0;
        const restoredBalance = currentBalance + amount;
        await updateBankAccountBalance(payment.payment_source_id, restoredBalance);
      }
      
    } else if (payment.payment_source === 'credit_card' && payment.payment_source_id) {
      const card = await dbOperation('creditCards', 'get', payment.payment_source_id);
      if (card) {
        const currentBalance = Number(card.balance) || 0;
        const restoredBalance = Math.max(0, currentBalance - amount);
        await dbOperation('creditCards', 'put', {
          ...card,
          balance: restoredBalance
        }, { skipActivityLog: true });
      }
      
    } else if (payment.payment_source === 'cash_in_hand') {
      const currentCash = await getCashInHand();
      const restoredCash = currentCash + amount;
      await updateCashInHand(restoredCash);
    }

    // Restore loan balance
    const loan = await dbOperation('loans', 'get', payment.loan_id);
    if (loan) {
      const restoredBalance = (payment.balance_before !== undefined && payment.balance_before !== null)
        ? Number(payment.balance_before)
        : Number(loan.balance) + amount;

      await dbOperation('loans', 'put', {
        ...loan,
        balance: restoredBalance,
        next_payment_date: payment.due_date, // Roll back to the due date
        recurring_occurrences_completed: Math.max(0, (loan.recurring_occurrences_completed || 0) - 1)
      }, { skipActivityLog: true });
    }

    // Mark payment as undone
    await supabase
      .from('loan_payments')
      .update({
        status: 'undone',
        undone_at: new Date().toISOString()
      })
      .eq('id', paymentId);

    // Mark transaction as undone
    if (payment.transaction_id) {
      await supabase
        .from('transactions')
        .update({
          status: 'undone',
          undone_at: new Date().toISOString()
        })
        .eq('id', payment.transaction_id);
    }

    console.log('‚úÖ Loan payment undone successfully');
    return true;

  } catch (error) {
    console.error('Error undoing loan payment:', error);
    throw error;
  }
}
